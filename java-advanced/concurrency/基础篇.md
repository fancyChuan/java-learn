# 基础篇

## 一、 线程基础
进程 | 线程
--- | ---
代码在数据集合上的一次运行互动 | 进程的一个实体，一次运行路径（函数调用路径）
系统进行资源（除CPU）分配和调度的基本单位 | CPU分配的基本单位
一个进程至少有一个线程 | 多个线程共享进程的资源

> java中启动main函数就启动了JVM进程，main函数所在的进程也叫主线程

如下图：多个线程共享进程的堆和方法区资源，每个线程有自己的程序计数器和栈区域

![iamge](https://github.com/fancychuan/java-learn/tree/master/java-advanced/img/进程线程关系图.png?raw=true)

- 程序计数器为何设计成线程私有？
> CPU使用时间片轮转方式让线程轮询占有，也就是说任何一个时间点（时间片）只能有一个线程使用一个CPU核。在线程切换的时候需要记录该线程让出CPU时的执行地址，再次分配时再从自己私有的计数器指定的位置继续执行。
> 注意：如果执行native方法，那么pc计数器记录的是undefined地址，执行的是java代码时计数器记录的才是下一跳指令的地址
- 每个线程的**栈**资源用于存储该线程的局部变量，这些也是线程私有的。
- **堆**内存最大，被所有线程共享，在进程创建时分配，主要存放使用new操作常见的对象的实例
> todo: 在方法中通过new创建的对象存在哪里？是不是也属于局部变量？ 
> 应该是这样，在方法中 B b = new B() 创建的对象的数据是存在堆中的，而b作为局部变量中的引用变量，在栈中存的只是对象的引用
- 方法区：存放JVM加载的类、常量、静态变量等，也是线程共享

### 1. 线程创建与运行
三种创建方式：
- 继承Thread类
    - 好处：在run()方法中获取当前线程直接使用this就可以了，无须使用Thread.currentThread() 方法。也方便传参，通过set方法或者构造函数
    - 坏处：1.java不支持多继承，继承了Thread类就无法继承其他类。 2.任务和代码没有分开，当多个线程需要执行相同的任务，就需要多次写同样的代码
- 实现Runable接口
    - 代码可复用
    - 坏处：只能使用主线程中被声明为final的变量；任务没有返回值。继承Thread类也一样，没有返回值
- 使用FutureTask方式
    - 可以获取返回值

参照：[CreateThreadApp.java](https://github.com/fancychuan/java-learn/tree/master/javase/src/multithreads/CreateThreadApp.java)

### 2. 线程通知与等待
Object类是所有类的父类，有wait() notify() notifyAll()三个跟线程通知与等待相关的函数

#### 2.1 wait()函数
当线程调用一个共享变量的wait()方法时，该调用线程就会阻塞直到以下两个事情之一发生：
- (1)其他线程调用了该对象的notify()或者notifyAll()方法
- (2)其他线程调用了该线程的interrupt()方法，该线程抛出InterruptException异常返回
> 注意：如果调用wait()方法的线程没有事先获得该对象的**监视器锁**，会抛异常

获取监视器锁的方式：
- 执行synchronized同步代码块时，使用该共享比阿娘作为参数
```
synchronized (共享变量) {
    // do something
}
```
- 代用该共享变量的方法，并且该方法使用synchronized修饰
```
synchronized void add(int a, int b) {
    // do something
}
```

**虚假唤醒**：一个线程从挂起状态变为运行状态，但没有被其他线程调用notify()、notifyAll()方法进行通知或者被中断或者等待超时的现象。虽然很少发生，稳妥的办法是不断的调用wait()方法
```
// 经典的调用共享变量wait()方法的实例
synchronized (obj) {
    while (条件)  (
        obj.wait() 
    )
}
```

wait(long timeout) timeout=0的时候跟wait()一样，为负数的时候抛异常

wait(long timeout, int nanos) nanos>0的时候timeout+1


#### 2.2 notify()
该方法被调用后，调用了wait()方法的线程就会被唤醒，一个共享变量上可能会有多个线程在等待，具体唤醒哪一个是随机的

此外，被唤醒的线程不能马上继续执行，它必须在获取了共享对象的监视器锁之后才可以。也就是说，唤醒了等待线程的线程释放了锁之后，被唤醒的线程需要和其他线程一起去竞争这个锁，之后竞争到了才可以继续执行

#### 2.3 notifyAll()
唤醒所有调用了共享变量的wait()方法而被挂起的线程