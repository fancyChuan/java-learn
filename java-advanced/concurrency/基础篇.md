# 基础篇
## 一、 并发编程的挑战
### 1. 上下文切换
- 上下文切换：任务从保存到再加载的过程就是一次上下文切换。
- 多线程不一定快，因为线程有创建和上下文切换的开销。参见：[ConcurrencyAndSerialApp.java](https://github.com/fancychuan/java-learn/tree/master/java-advanced/src/main/java/concurrency/base/threads/ConcurrencyAndSerialApp.java)
- 如何减少上下文切换？
    - 无锁并发编程：多线程竞争锁时会引起上下文切换，因此多线程处理数据时让不同的线程处理不同段的数据（比如通过hash算法对数据分段）
    - CAS算法：Atomic包使用CASh算法来更新数据，不需要加锁。TODO：？？
    - 使用最少线程：任务不多就尽量不创建线程
    - 协程：在但线程中实现多任务的调度，并在单线程里维持多个任务空间的切换

> java中的线程与操作系统的原生线程一一对应，当阻塞一个线程时，需要从用户态切换到内核态执行阻塞操作，也就需要把任务先保存起来，等到被唤醒了再重新加载。这也就是所谓的上下文切换

### 2. 死锁
参见：[DeadLockApp.java](https://github.com/fancychuan/java-learn/tree/master/java-advanced/src/main/java/concurrency/base/threads/DeadLockApp.java)
- 死锁产生的原因：
    - t1线程拿到锁，因为异常原因没有释放所(死循环)，或者t1拿到一个数据库锁，释放锁的时候抛出了异常没有释放掉
- 避免死锁的常见方法：
    - 避免一个线程同时获取多个锁
    - 避免一个线程在锁内同时占用多个资源，尽量保证每个锁值占用一个资源
    - 尝试使用定时锁，使用lock.tryLock(timeout)来替代使用内部所机制
    - 对于使用数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况
### 3. 资源限制的挑战
- 并发编程时，程序的执行速度也是受计算机硬件资源或软件资源的限制。
- 受资源限制时，会导致程序反比串行执行慢，因为增加了上下文切换和资源调度的时间。比如并发的下载和处理数据，导致CPU使用率达到100%，几个小时无法完成，改成单线程后1个小时就完成了
- 资源受限时的并发编程思路：根据不同的资源限制调整程序的并发度

## 二、 线程基础
进程 | 线程
--- | ---
代码在数据集合上的一次运行互动 | 进程的一个实体，一次运行路径（函数调用路径）
系统进行资源（除CPU）分配和调度的基本单位 | CPU分配的基本单位
一个进程至少有一个线程 | 多个线程共享进程的资源

> java中启动main函数就启动了JVM进程，main函数所在的进程也叫主线程

如下图：多个线程共享进程的堆和方法区资源，每个线程有自己的程序计数器和栈区域

![iamge](https://github.com/fancychuan/java-learn/tree/master/java-advanced/img/进程线程关系图.png?raw=true)

- 程序计数器为何设计成线程私有？
> CPU使用时间片轮转方式让线程轮询占有，也就是说任何一个时间点（时间片）只能有一个线程使用一个CPU核。在线程切换的时候需要记录该线程让出CPU时的执行地址，再次分配时再从自己私有的计数器指定的位置继续执行。
> 注意：如果执行native方法，那么pc计数器记录的是undefined地址，执行的是java代码时计数器记录的才是下一跳指令的地址
- 每个线程的**栈**资源用于存储该线程的局部变量，这些也是线程私有的。
- **堆**内存最大，被所有线程共享，在进程创建时分配，主要存放使用new操作常见的对象的实例
> todo: 在方法中通过new创建的对象存在哪里？是不是也属于局部变量？ 
> 应该是这样，在方法中 B b = new B() 创建的对象的数据是存在堆中的，而b作为局部变量中的引用变量，在栈中存的只是对象的引用
- 方法区：存放JVM加载的类、常量、静态变量等，也是线程共享

### 1. 线程创建与运行
三种创建方式：
- 继承Thread类
    - 好处：在run()方法中获取当前线程直接使用this就可以了，无须使用Thread.currentThread() 方法。也方便传参，通过set方法或者构造函数
    - 坏处：1.java不支持多继承，继承了Thread类就无法继承其他类。 2.任务和代码没有分开，当多个线程需要执行相同的任务，就需要多次写同样的代码
- 实现Runable接口
    - 代码可复用
    - 坏处：只能使用主线程中被声明为final的变量；任务没有返回值。继承Thread类也一样，没有返回值
- 使用FutureTask方式
    - 可以获取返回值

参照：[CreateThreadApp.java](https://github.com/fancychuan/java-learn/tree/master/javase/src/multithreads/CreateThreadApp.java)

### 2. 线程通知与等待
Object类是所有类的父类，有wait() notify() notifyAll()三个跟线程通知与等待相关的函数

#### 2.1 wait()函数
当线程调用一个共享变量的wait()方法时，该调用线程就会阻塞直到以下两个事情之一发生：
- (1)其他线程调用了该对象的notify()或者notifyAll()方法
- (2)其他线程调用了该线程的interrupt()方法，该线程抛出InterruptException异常返回
> 注意：如果调用wait()方法的线程没有事先获得该对象的**监视器锁**，会抛异常

获取监视器锁的方式：
- 执行synchronized同步代码块时，使用该共享比阿娘作为参数
```
synchronized (共享变量) {
    // do something
}
```
- 代用该共享变量的方法，并且该方法使用synchronized修饰
```
synchronized void add(int a, int b) {
    // do something
}
```

**虚假唤醒**：一个线程从挂起状态变为运行状态，但没有被其他线程调用notify()、notifyAll()方法进行通知或者被中断或者等待超时的现象。虽然很少发生，稳妥的办法是不断的调用wait()方法
```
// 经典的调用共享变量wait()方法的实例
synchronized (obj) {
    while (条件)  (
        obj.wait() 
    )
}
```

wait(long timeout) timeout=0的时候跟wait()一样，为负数的时候抛异常

wait(long timeout, int nanos) nanos>0的时候timeout+1


#### 2.2 notify()
该方法被调用后，调用了wait()方法的线程就会被唤醒，一个共享变量上可能会有多个线程在等待，具体唤醒哪一个是随机的

此外，被唤醒的线程不能马上继续执行，它必须在获取了共享对象的监视器锁之后才可以。也就是说，唤醒了等待线程的线程释放了锁之后，被唤醒的线程需要和其他线程一起去竞争这个锁，之后竞争到了才可以继续执行

#### 2.3 notifyAll()
唤醒所有调用了共享变量的wait()方法而被挂起的线程


### 3. 等待线程执行终止的join方法
由Thread类直接提供

### 4. 让线程休眠的sleep方法
sleep为静态方法，调用之后该线程会暂时让出指定时间的执行权（不参与CPU的调度），但是该线程所持有的监视器资源（比如锁），还是持有不让出的。


### 5. 让出CPU执行权的yield方法
也是静态方法，


## 三、线程其他
### Unsafe类
Unsafe提供了硬件级别的原子性操作，该类中都是native方法，使用JNI的方式访问本地C++实现库。

### java指令重排序
java内存模型允许编译器和处理器对指令重排序以提高运行性能，并且只会对不存在数据依赖性的指令重排序。单线程运行结果是一致的，但多线程环境下就会有问题。

我们需要使用volatile来修饰共享变量来避免重排序和内存可见性问题

### 伪共享
现象描述：一个缓存行中有多个变量时，当多线程同时修改一个缓存行里的多个变量，由于同时只能有一个线程操作缓冲行，那么其他线程在操作时就需要去二次

缓存一致性：

程序运行的局部性原理：