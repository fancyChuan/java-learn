## 面向对象
面向对象的基本特征：封装、继承、多态

多态可以直接理解为，子类对象可以直接赋值给父类变量，当运行时依然表现出子类的行为特征。

面向对象软件开发需要经过：OOA(面向对象分析)、OOD(面向对象设计)、OOP(面向对象编程)

类之间有三种基本关系：
- 关联
    - 单向关联：学生->老师 但是老师无法访问到学生
    - 双向关联
    - 聚合：A学生同时两个俱乐部的成员，学生聚合成了俱乐部。(实体可以同时是多个聚合成的实体的一部分)
    - 组合：手臂、脸等组合成人。（某个实体只能属于另一个实体的一部分）
- 泛化（与继承同一个概念）
- 依赖（通常是单向的）
    - 改动的类将消息发给另一个类
    - 改动的类以另一个类作为数据部分
    - 改动的类以另一个类作为操作参数


> UML的介绍见《疯狂java讲义》P28-

关于类的几个小知识：
- static修饰的成员不能访问没有static修饰的成员（静态成员不能访问非静态成员）
- static修饰的成员表明它属于类本身，而不属于该类的单个实例。也就是静态成员，而不是实例成员（变量、方法）
- static的真正作用是用于区分成员变量、方法、内部类、初始化块这四种成员是属于类本身还是属于实例。
- static不能和this合用
- 构造器： 不能定义返回值类型，构造器名要与类名一致
- 类的对象实际存放在堆(heap)内存中，java不允许直接访问堆内存，只能通过对象的应用操作该对象
- 类是一种**引用类型**，对象的引用是存在**栈内存**
- 希望通知垃圾回收机制回收某对象，只需要把该引用变量赋值为null
- 虽然可以，但是不要用实例变量去访问静态成员，而是用类去访问静态成员

关于方法的几个知识：
- java的参数传递机制只有一种：**值传递**。也就是说，传值的复制品到方法，实参本身不受影响。（方法栈中会存有实参的一个副本，方法改变的是这个副本）
> 参见 SomeCases.testReferenceInstance()
- 形参个数可变的方法： 在最后一个形参的类型后增加 (...)  这样多个参数值就会被当成数组传入，例如 testMultiParams(int a, String... books)
    - 本质是一个数组参数 等同于 testMultiParams(int a, String[] books)
    - testMultiParams(int a, String... books) 调用的时候更加便捷，不需要先存为数组再传入方法
    - 一个方法最多只能有一个长度可变的形参
> 参见 SomeCases.testMultiParams(int a, String... books)
- **方法重载**： 同一类中，方法名相同，形参列表不同（方法返回值类型、修饰符等跟方法重载没关系）

关于变量
- java允许局部变量名与成员变量名相同，虽然会覆盖，但可以通过this或者类名来限定访问成员变量
> 参见 SomeCases.testOverwrite()
- 把变量写成成员变量的坏处（相比局部变量）：
    - 增大了变量的生存时间，导致更大的内存开销
    - 扩大了变量的作用域，不利于提高程序的内聚性（因为成员变量的作用域为类存在范围或者对象存在范围）
- 应使用成员变量的情况：
    - 变量用于描述某个类或者对象的固有信息时，比如人的眼睛数量为2
    - 需要以一个变量来保存该类或实例运行时的状态信息时
    - 某个信息需要在多个方法中共享时


java的访问控制级别（由小到大）： 
```
private(当前类访问权限) -> default(包访问权限) -> protected(子类访问权限) -> public(公共访问权限)
```
- protected 子类访问权限，同包的其他类也可以访问，包括实例化后的对象也可以，如果是private，那么实例化后的对象也不能访问
- default 只是同包的其他类可以访问，子类不一定可以。
- 只有成员变量才需要控制访问权限，局部变量不需要
- 外部类只有 public 和 default两种权限
- 符合javaBean规范： 类的变量使用private，同时提供public的setter、getter方法
- 访问控制符的使用原则：
    - 绝大多数成员变量应该用private修饰，只有static修饰的，类似于全局变量的才考虑public。
    - 用于辅助实现该类其他方法的工具方法，也应该使用private修饰
    - 一个类只做父类，并且只希望被子类重写，就该使用protected修饰
    - 希望暴露出来给其他类自由使用的方法就用public修饰

包与导入
- java5以后import可以静态导入。比如  import static package.ClassName.fieldName | methodName 导入某个类的静态变量或者静态方法


构造器
- 构造器最大的用处就是创建对象时执行初始化。
- 构造器的重载：类中提供多个构造器
- 可以通过this来调用相应的构造器，来完成另一个构造器的构造，比如 SomeCases.MultiConstruct
    - this的这种用法只能在构造器中使用
    - 必须放在构造器的第一条语句


类的继承
- java是单继承，只能有一个直接父类
- java子类不能获得父类的构造器
- 重写父类方法
    - 子类中可以调用被重写的父类方法，通过super关键词来获取父类，这个与局部变量覆盖成员变量当可以通过this来区分相类似
    - 重写的要求：
        - 两同： 方法名相同、参数列表相同
        - 两小： 子类返回值类型比父类的更小或相等； 子类方法抛出异常类应该比父类抛出的更小或相等
        - 一大： 子类方法的访问权限应该比父类的更大或相等
        - 覆盖方法与被覆盖方法需要都为静态方法或者都为实例方法
    - 如果父类的方法使用private修饰的，那么子类无法重写
    - this, super不能出现在static修饰的方法中
- super
    - 让子类可以调用父类的构造器，用法与this类型， 比如 super(name1, name2) 
    - 用于限定该对象调用它从父类继承得到的**实例变量和方法**
    - 在构造器中使用super则限定该构造器初始化的是从父类继承得到的实例变量，而不是该子类自己定义的实例变量
    - 子类定义了和父类相同的变量，可以通过super区分
> 当覆盖类变量或者类方法是，可以直接通过类名访问
> 当创建一个子类对象时，系统会为该对象分配两个内存，一个用来存储子类定义的变量，另一个用来存储从父类继承来的变量

多态
- java引用变量有两种：编译时类型、运行时类型。其中时类型由声明决定，运行时类型则由实际赋予的对象决定。当两者不一致的时候，就可能出现多态
- **向上转型**：java允许把子类对象直接赋值给父类引用变量，转换的过程有系统自动完成
- 多态：相同类型的变量、调用同一方法时呈现出多种不同的行为特征。父类引用变量在调用方法时，方法行为表现为子类方法的行为特征。
- 与方法不同，实例变量不具有多态性。Parent p = new Children() p.实例变量获取还是父类的实例变量
- 引用变量只能调用它所声明的类型所包含的方法，也就是编译时类型的方法，而不能调用运行时类型的方法，如果需要，那么就要通过**强制类型转换**
    - 基本类型之间的转换只能在数值类型之间进行。包括：整型、字符型、浮点型
    - 引用类型之间的转换只能在具有**继承关系**的两个类型之间进行
    - 进行强制类型转换之间，一般都需要想过instanceof运算符判断是否可以转换
    
    
继承和组合
- 继承带来高度复用的同时，也带来了一个坏处：破坏父类的封装
- 为保证父类有良好的封装性，设计父类因注意：
    - 尽量隐藏父类的内部数据，使用private
    - 不让子类随意访问、修改父类的方法。
        - 用于辅助的工具方法，应该用private修饰
        - 需要被外部访问，同时又不希望又不希望被修改的，设为 public final
        - 方法只能被子类修改，不让其他类自由访问，用protected
    - 尽量不在父类构造器中调用将要被子类重写的方法
- 让类成为最终类，而不是父类的方法：
    - 使用private修饰父类的构造器，可以保证子类因为无法调用构造器而不能继承父类
    - 使用final修饰类
- 何时需要派生子类？不仅仅需要保证子类是一种特殊的父类，还需要满足：
    - 子类需要额外的属性
    - （或者）子类需要增加自己独有的行为方式
- 利用组合实现复用
    - 把类作为新类的一部分，在新类中调用旧类的public方法
    - 一般用public修饰用于旧类，避免新类暴露出旧类。比如  class Bird {private Animal a; ...} 这样就可以不继承Animal类
    
初始化块
- 是java类的第4中成员（变量、方法、构造器、初始化块），在创建对象时隐式执行
- 在构造器之前执行，初始化块的修饰只能是static
- 如果有一段初始化代码**无须接收任何参数**且对任何对象一直，就可以把这段代码提取到初始化块中
- 都是普通的初始化块，则顺序执行，如果有static修饰的静态初始化块，则优先执行静态初始化块
> 参见 SomeCAses.InitBlock
- 普通初始化块对对象执行初始化，而静态初始化块对类进行初始化
- 一旦对一个类初始化之后，JVM中就会存在这个类，再次初始化的时候不会执行静态初始化块
- 静态初始化块与类中定义的静态变量都属于初始化块，执行顺序与代码中的位置一致

包装类
- JDK1.5以后支持自动装箱、自动拆箱 如 Integer i = 5; int ii = i;
- 将基本类型与 "" 进行连接操作，系统会自动把基本类型变量转为字符串
- 包装类型可以与基本类型比较，比如 Integer i=5; a>4.0 会返回true
- 包装类型之间的比较相对复杂，只有两包装类型指向同一个对象时才会返回true
> 参见 SomeCases.testWrapper()

处理对象
- toString() 重写以打印出想要的对象信息
- String n1 = "hello" 和 String n2 = new String("hello")的区别
    - n1 在常量池中，编译时就能确定
    - n2 这行语句执行会产生两个字符串对象，一个在常量池中，一个是通过String构造器根据"hello"直接量创建的一个新的对象（放在堆内存）
    - JVM 常量池保证相同字符串的直接量只有一个，所以 String n2 = "he" + "llo" 编译时能确定，跟n1是同一个对象
- 重写 equals() 方法可以支持自定义相等标准。比如String.equals() 则判断两字符串是否包含相同的字符序列
- instanceOf 当前面对象是后面类的实例或者其子类的实例时，都返回true

类成员
- 使用static修饰的成员，为类所有。
- 在系统第一次准备使用该类时就会为类变量分配内存空间，类变量开始生效，知道该类被卸载
- 很多语言不支持对象直接访问类变量，而java中可以理解为系统在底层做了转换才能让对象直接访问到类变量
- 即使某个实例对象为null，也可以访问类变量
- 静态初始化块也是类成员的一部分
- 单例类
    - 把该类的构造器用private修饰，从而把构造器隐藏起来
    - 根据良好封装的原则：一旦用private修饰构造器，那么就需要提供一个public访问点用于创建该类的对象，且该方法是static修饰的
    - 还需要缓存该对象
> 参见 Singleton.java
    
final修饰符
- 表示一旦获得了初始值就不可被改变
- 系统不会对final修饰的变量进行隐式初始化，必须显示赋值。如果在初始化前使用这个变量会报错
- final修饰形参的时候，由传入的值完成处理化，在代码中不能再次赋值。如function test(final String xx) 在调用test("hello") 的时候就会初始化xx
- final修饰引用类型时，仅仅保证这个引用类型变量所引用的地址不会改变，即一直引用同一个对象，但对象是可以改变的
- “宏变量”：final修饰的变量完成初始化，并且在编译时可以确定下来，那么这个变量就相当于一个直接量，不再是变量了。可以叫为宏变量
- final修饰的方法，不可被重写
- final修饰的类，不可以有子类
- 不可变类： 创建该类的实例后，该实例的实例变量不可改变。
    - private final 修饰成员变量
    - 不提供setter方法
    有必要时重写Object的hashCode() equals() 方法
- 缓存不可变类 参见 CacheImmutable.java

抽象类
- 抽象方法&抽象类
    - 抽象方法：只有方法签名，没有方法实现
    - 有抽象方法的类只能被定义为抽象类（抽象类里可以没有抽象方法），有三种情况
        - 直接定义一个抽象方法
        - 继承一个抽象父类的，按时没有完全实现父类包含的方法
        - 实现了一个接口，但是没有完全实现接口包含的抽象方法
    - 抽象类不能被实例化，无法使用new关键词
    - 抽象类的构造器不能用于创建实例，主要是用来被子类调用
    - abstract 不能修饰构造器，没有抽象构造器，抽象类里的构造器只能是普通构造器
    - static和abstract不能同时修饰某个方法，因为static修饰的方法是属于类的，但是抽象类的方法不提高方法体，因此调用是会报错的
    - abstract方法不能定义为private访问权限，否则这个方法永远不会有方法体
> 抽象方法和空方法体不是一个概念： public abstract void test(); 与public void test(){};
- 抽象类的作用
    - 以抽象类作为其子类的模版，避免了子类设计的随意性
    - 抽象类体现的是一种模版模式的设计，抽象方法推迟到子类中去实现

java8改进的接口
- 接口的概念
    - 接口里不能包含普通方法，接口里的所有方法都是抽象方法
    - java8允许在接口中定义**默认方法**，默认方法可以提供方法实现
    - 接口是从多个相类似的类中抽象出来的规范，体现的是规范与实现分类的设计哲学（接口的好处）
    - 和类相比，接口少了两种成员（初始化块、构造器）：成员变量（只能是静态**常量**），方法（只能是抽象方法、类方法，默认方法），内部类（内部接口、枚举）定义
    - 接口中如果要只能访问控制符，只能是public
    - 对于静态常量而言，不管有没有用static final，系统都会加上。可以通过接口直接访问
    - 接口中定义默认方法，要加default修饰符。只能由接口的实现类的实例来调用这些默认方法
    - 默认方法、类方法需要有实现方法体。类方法可以直接使用接口来调用
    - 接口的继承：支持多继承，可以有多个直接父接口
    - 实现接口方法是，必须使用public，因为子类重写父类方法时访问权限只能更大或者相等
- 接口的用途
    - 定义变量，也可以用于进行强制类型转换
    - 调用接口中定义的变量
    - 被其他类实现
- 接口和抽象类
    - 接口作为系统与外界交互的窗口，体现的是一种规范。而抽象类作为多个子类的共同父类，体现的是一种模版式设计
    - 接口中不能定义静态方法，而抽象类可以
    - 接口只能保护抽象方法和默认方法，而抽象类可以保护普通方法
    - 接口只能定义静态常量，而抽象类还可以定义普通成员变量
    - 接口不包含构造器、初始化块，而抽象类可以
    - 一个类最多只有一个父类，但是接口可以继承多个接口
- 面向接口编程
    - 简单工厂模式: 把创建对象的任务交给一个类去实现
    - 命令模式：把命令对象作为一个参数传到方法中，由该方法去执行命令对象的方法
    
内部类(也叫嵌套类)
- 内部类作用
    - 内部类提供了更好的封装，把内部类实现细节隐藏在外部类之内，不允许同包其他类访问
    - 内部类成员可以访问外部类的私有数据，但外部类不能访问内部类的实现细节
    - 匿名内部类适合用于仅需要使用一次的类
- 内部类和其他类的区别
    - 定义在类的内部
    - 内部类可以比外部类多使用三个修饰符：private、protected、static
    - 非静态内部类不可以拥有静态成员
> 外部类的上一级是包，只有两个作用域：同包、任意位置。因为static修饰的是属于类的，而外部类上一级是包，因此也不能用static修饰
- 分类
    - 非静态内部类
        - 非静态内部类访问变量时，但与外部类的成员变量相同时，可以通过this来获取内部类变量，通过外部类名.this来获取外部变量。参见innerClass.SameVariable.java
        - 非静态内部类可以访问外部类的private成员，但反过来就不成立，必须显式实例化内部类。参见 innerClass.Outer.java
        - 非静态内部类对象必须寄生在外部类对象里
        - 不允许在外部类的静态成员中直接使用非静态内部类
        - 非静态内部类里不允许定义静态成员，包括：静态方法、静态成员变量、静态初始化块
    - 静态内部类（也叫类内部类）
        - 属于外部类本身，而不是属于外部类对象
        - 静态内部类不能访问外部类的实例成员（静态成员不能访问非静态成员）
        - 静态内部类的实例方法也不能访问外部类的实例成员
        - java还允许在接口中定义内部类，默认使用public static修饰，也就是说接口中的只能是静态内部类
    - 按照所处位置分：成员内部类、局部内部类、匿名内部类
- 使用
    - 在外部类内部使用内部类
    - 在外部类以外使用非静态内部类
        - 此时，内部类不能使用private修饰符
        - 定义变量的语法：OuterClass.InnerClass varName; 参见 innerClass.CreateInnerInstance.java
        - 非静态内部类的构造器必须通过外部类的实例对象来调用
    - 在外部类以外使用静态内部类
        - 创建静态内部类对象时无需创建外部类对象，常用语法为： new OuterClass.InnerClass();
        - 参见 innerClass.CreateStaticInnerInstance
        - 使用静态内部类比使用非静态内部类要简单很多，只要把外部类等成静态内部类的**包空间**就可以了，因此优先考虑使用静态内部类
- 局部内部类
    - 把内部类定义在方法中，上一次单元是方法，因此使用static修饰内部类没有任何意义
    - 局部内部类的有效范围仅在方法内，不能在方法以外的任何地方使用
    - 这是一个是否“鸡肋”的语法，实际开发中很少用到
- java8改进的匿名内部类
    - 适合于创建只使用一次的类
    - 匿名内部类需要继承一个父类或者实现一个接口，但最多只能有一个父类或者一个接口
    - 匿名内部类不能使抽象类。系统会立即创建对象
    - 匿名内部类不能定义构造器。因为没有类名，所以无法定义构造器
    - java8之前，被局部内部类、匿名内部类访问的局部变量要使用final修饰，java8之后，该限制被取消，这种情况下系统相当于自动给这种局部变量加上了final

java8新增的Lambda表达式
- Lambda表达式相当于是一个匿名方法，主要用来代替匿名内部类的繁琐语法
- 由： 形参列表 -> 代码块 组成。如果代码块需要返回值，在没有return的情况下，而代码块又仅有一个省略了return的语句，Lambda会自动返回这条语句的值
- Lambda表达式实际上会被当成一个“任意类型”的对象
- Lambda表达式与函数式接口
    - Lambda表达式的类型也叫“目标类型”，目标类型必须是函数式接口（只包含**一个抽象方法**的接口，可以有多个类方法、默认方法）
    > 目标类型应该理解为：由Lambda表达式转给的那个对象的类型决定。比如传给eat(Eatable)那就是Eatable类型，传给 fly(Flyable) 就是Flyable类型 
    - Lambda表达式的限制：
        - 目标类型必须是明确的函数式接口。常见的方法有：
            - 将Lambda表达式赋值给函数式接口类型的变量 参见 lambda.LambdaTest.java 下的testFunction()
            - 将Lambda表达式作为函数式接口类型的参数传给某个方法 如 lambda.LambdaTest.java 的 testLambdaUsage()
            - 使用函数式接口对Lambda表达式进行强制类型转换 如 lambda.LambdaTest.java 的testFunction()
        - 只能为函数式接口创建对象。（Lambda表达式只能实现一个方法，一次只能为只有一个抽象方法的接口创建对象）
    - java8在java.util.function下预定义了大量的函数式接口
        - XxxFunction： 包含apply抽象方法，用于将参数转成另一个值
        - XxxConsumer： accept抽象方法，对参数处理、消费，但没有返回值
        - XxxPredicate： test抽象方法，判断是否满足特定条件，返回boolean
        - XxxSupplier： getAsXxx抽象方法，无参，按照Lambda表达式的逻辑返回一个值
- 方法引用与构造器引用
    - Lambda代码块中**只有一行代码**时，可以省略花括号，同时也可以使用方法引用和构造器引用
    - 方法引用和构造器引用可以让Lambda表达式更加简洁
    - Lambda支持的几种引用类型，使用示例参见 LambdaTest.testUsing()
    
    种类 | 示例 | 说明
    --- | --- | ---
    引用类方法 | 类名::类方法 | 
    引用特定对象的实例方法 | 特定对象::实例方法 | 函数式接口中被实现方法的全部参数传给该类方法作为参数
    引用某类对象的实例方法 | 类名::实例方法 | 函数式接口中被实现方法的第一个参数作为调用者，后面的参数全部传给该方法作为参数
    引用构造器 | 类名::new | 函数式接口中被实现方法的全部参数传给该构造器作为参数
- Lambda与匿名内部类的联系与区别
    - 相同点：
        - 都可以直接访问"effectively final"的局部变量，以及外部成员变量
        - 两者创建的对象都可以直接调用从接口中继承的默认方法
    - 不同点：
        - 匿名内部类可以为任意接口创建实例——不管接口包含多少抽象方法，但Lambda只能为函数式接口创建实例
        - 匿名内部类可以为抽象类甚至普通类创建实例，而Lambda只能为函数式接口创建实例
        - 匿名内部类实现的抽象方法的方法体允许调用接口中定义的默认方法；但Lambda的代码块不允许调用接口中定义的默认方法，Lambda的实例对象可以。
    - 参见 LambdaAndInner.java
- Lambda调用Arrays的类方法
    - 参见 LambdaTest.testLambdaArrays()
    
枚举类
- 类的对象是有限且固定的，比如季节，这些类就叫枚举类，JDK1.5以后就开始支持枚举类，关键词是enum，地位和interface、class相同
- 和普通类的区别（枚举类是一个特殊类）
    - 枚举类默认继承 java.lang.Enum 因此不能显式继承其他父类。其中java.lang.Enum实现了java.lang.Serializable和java.lang.Comparable
    - 使用enum定义、非抽象的枚举类默认会使用final修饰，因此不能派生子类
    - 枚举类的构造器只能使用private访问控制符，如果省略，系统也会默认使用private修饰
    - 枚举类的所有实例必须在枚举类的第一行显式列出，否则不能产生实例。列出实例是，系统会自动添加public static final修饰
```
public enum SeasonEnum {
    // 在第一行列出4个枚举实例
    SPRING, SUMMER, FALL, WINTER;
}
```
- 默认提供values()方法可以获取所有的枚举值
- 常用方法：
    - int compareTo(E o)
    - String name(); String toString()
    - int ordinal() 
    - valueOf()：获取指定枚举类的枚举值，参见 Main.testGender()
- 枚举类通常会设计成不可变类，也就是说类的成员变量不允许改变。参见 Gender.Gender3
    - 成员变量都用private final修饰
    - 使用了final修饰，那么就必须在构造器里为这些成员变量执行初始值
> 不是所有的枚举类都使用了final，非抽象的枚举类才默认使用final修饰
- 包含抽象方法的枚举类 参见Operation.java

对象与垃圾回收
- 特征
    - 垃圾回收机制只负责回收堆内存中的对象，不回收任何物理资源（如数据库连接、网络IO等）
    - 程序无法精确控制垃圾回收的运行，垃圾回收会在合适的时候进行（失去引用后）
    - 回收任何对象之前，会先调用对象的finalize()方法，该方法可能使对象重新复活（重新引用），从而取消垃圾回收
- 在内存中的状态
    - 可达状态
    - 可恢复状态
    - 不可达状态
- 强制垃圾回收
    - 调用System类的gc()静态方法：System.gc()
    - 调用Runtime对象的gc()实例方法: Runtime.getRuntime().gc()
    - 这种强制其实只是通知系统尽快进行垃圾回收
- finalize() 原型：protected void finalize() throws Throwable
    - 当**方法返回后**，对象消失，垃圾回收机制开始执行
    - 特点：
        - 永远不要主动调用某个对象的的finalize方法，该方法应该交给垃圾回收机制调用
        - finalize()方法何时被调用是否被调用具有不确定性，系统只有在有严重内存需求的时候才会进行垃圾回收
        - JVM执行可恢复对象的finalize()方法时，可能使该对象或系统中其他对象变成可达状态
        - JVM执行finalize方法时出现异常，垃圾回收机制不会报告异常，程序进行执行
- 对象的软、弱、虚引用
    - 强引用：最常见的引用方法
    - 软引用：通过java.lang.ref.SoftReference类来实现。当只有软引用时，在系统内存不足时可能被回收。通常用于对内存敏感的程序中
    - 弱引用：通过WeakReference类实现，比软引用级别更低。当只有弱引用，在系统垃圾回收机制运行时，不管内存是否充足都会被回收
    - 虚引用：通过PhantomReference类实现，完全类似于没有引用。对象甚至感觉不到虚引用的存在。主要用于跟踪对象呗垃圾回收的状态，不能单独使用，必须跟引用队列ReferenceQueue
    - 引用队列：有java.lang.ref.ReferenceQueue表示，用于保存被回收后对象的应用。
> 如果使用软、弱、虚引用，就意味着系统可以随意的释放对象。但希望尽可能小的减小程序在其生命周期中所占的内存大小，使用这几个类就很有用处。
> 必须指出，当使用这几个引用时，就不能使用强引用，否则就浪费这三个特殊类的好处

其他修饰符：
- strictfp： FP-strict 精确浮点。修饰了类、接口、方法后，会在有效范围内严格按照浮点规范来执行
- native： 主要修饰方法，相当于抽象方法，只不过是会把这个方法交给C去实现。被修饰的方法意味着失去了跨平台性
- synchronized
- transient
- volatile

使用jar文件
- 全称：java archive file，Java档案文件。是一种压缩文件
- 使用jar包的好处
    - 安全，可以对jar包进行数字签名，只让特定用户使用
    - 加快下载速度
    - 压缩
    - 包封装。能让jar包里面的文件依赖于同一版本的类文件
    - 可移植性。能在各种平台直接使用
- jar命令
```
# 1. 不显示打包细节的创建jar包
E:\JavaWorkshop\java-learn\javase>jar cf baselib.jar src/baselib
# 2. 显示打包细节
E:\JavaWorkshop\java-learn\javase>jar cvf baselib.jar src/baselib
# 3. 参数M表示不生成清单文件
# 4. 自定义清单文件：jar cvfm test.jar xxxx.mf test 除了会默认生成清单目录，还会新增用户指定的清单文件 xxxx.mf （只是提取数据，而不是打包文件）
# 5. 查看jar包内容
E:\JavaWorkshop\java-learn\javase>jar tf baselib.jar
# 6. 查看jar包的详细内容
E:\JavaWorkshop\java-learn\javase>jar tvf baselib.jar
# 7. 解压缩 带详细信息
E:\JavaWorkshop\java-learn\javase>jar xfv baselib.jar
# 8. 更新jar包
```