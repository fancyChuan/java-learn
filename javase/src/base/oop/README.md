## 面向对象
面向对象的基本特征：封装、继承、多态

多态可以直接理解为，子类对象可以直接赋值给父类变量，当运行时依然表现出子类的行为特征。

面向对象软件开发需要经过：OOA(面向对象分析)、OOD(面向对象设计)、OOP(面向对象编程)

类之间有三种基本关系：
- 关联
    - 单向关联：学生->老师 但是老师无法访问到学生
    - 双向关联
    - 聚合：A学生同时两个俱乐部的成员，学生聚合成了俱乐部。(实体可以同时是多个聚合成的实体的一部分)
    - 组合：手臂、脸等组合成人。（某个实体只能属于另一个实体的一部分）
- 泛化（与继承同一个概念）
- 依赖（通常是单向的）
    - 改动的类将消息发给另一个类
    - 改动的类以另一个类作为数据部分
    - 改动的类以另一个类作为操作参数


> UML的介绍见《疯狂java讲义》P28-

关于类的几个小知识：
- static修饰的成员不能访问没有static修饰的成员（静态成员不能访问非静态成员）
- static修饰的成员表明它属于类本身，而不属于该类的单个实例。也就是静态成员，而不是实例成员（变量、方法）
- static的真正作用是用于区分成员变量、方法、内部类、初始化块这四种成员是属于类本身还是属于实例。
- static不能和this合用
- 构造器： 不能定义返回值类型，构造器名要与类名一致
- 类的对象实际存放在堆(heap)内存中，java不允许直接访问堆内存，只能通过对象的应用操作该对象
- 类是一种**引用类型**，对象的引用是存在**栈内存**
- 希望通知垃圾回收机制回收某对象，只需要把该引用变量赋值为null
- 虽然可以，但是不要用实例变量去访问静态成员，而是用类去访问静态成员

关于方法的几个知识：
- java的参数传递机制只有一种：**值传递**。也就是说，传值的复制品到方法，实参本身不受影响。（方法栈中会存有实参的一个副本，方法改变的是这个副本）
> 参见 SomeCases.testReferenceInstance()
- 形参个数可变的方法： 在最后一个形参的类型后增加 (...)  这样多个参数值就会被当成数组传入，例如 testMultiParams(int a, String... books)
    - 本质是一个数组参数 等同于 testMultiParams(int a, String[] books)
    - testMultiParams(int a, String... books) 调用的时候更加便捷，不需要先存为数组再传入方法
    - 一个方法最多只能有一个长度可变的形参
> 参见 SomeCases.testMultiParams(int a, String... books)
- **方法重载**： 同一类中，方法名相同，形参列表不同（方法返回值类型、修饰符等跟方法重载没关系）

关于变量
- java允许局部变量名与成员变量名相同，虽然会覆盖，但可以通过this或者类名来限定访问成员变量
> 参见 SomeCases.testOverwrite()
- 把变量写成成员变量的坏处（相比局部变量）：
    - 增大了变量的生存时间，导致更大的内存开销
    - 扩大了变量的作用域，不利于提高程序的内聚性（因为成员变量的作用域为类存在范围或者对象存在范围）
- 应使用成员变量的情况：
    - 变量用于描述某个类或者对象的固有信息时，比如人的眼睛数量为2
    - 需要以一个变量来保存该类或实例运行时的状态信息时
    - 某个信息需要在多个方法中共享时


java的访问控制级别（由小到大）： 
```
private(当前类访问权限) -> default(包访问权限) -> protected(子类访问权限) -> public(公共访问权限)
```
- protected 子类访问权限，同包的其他类也可以访问，包括实例化后的对象也可以，如果是private，那么实例化后的对象也不能访问
- default 只是同包的其他类可以访问，子类不一定可以。
- 只有成员变量才需要控制访问权限，局部变量不需要
- 外部类只有 public 和 default两种权限
- 符合javaBean规范： 类的变量使用private，同时提供public的setter、getter方法
- 访问控制符的使用原则：
    - 绝大多数成员变量应该用private修饰，只有static修饰的，类似于全局变量的才考虑public。
    - 用于辅助实现该类其他方法的工具方法，也应该使用private修饰
    - 一个类只做父类，并且只希望被子类重写，就该使用protected修饰
    - 希望暴露出来给其他类自由使用的方法就用public修饰

包与导入
- java5以后import可以静态导入。比如  import static package.ClassName.fieldName | methodName 导入某个类的静态变量或者静态方法


构造器
- 构造器最大的用处就是创建对象时执行初始化。
- 构造器的重载：类中提供多个构造器
- 可以通过this来调用相应的构造器，来完成另一个构造器的构造，比如 SomeCases.MultiConstruct
    - this的这种用法只能在构造器中使用
    - 必须放在构造器的第一条语句


类的继承
- java是单继承，只能有一个直接父类
- java子类不能获得父类的构造器
- 重写父类方法
    - 子类中可以调用被重写的父类方法，通过super关键词来获取父类，这个与局部变量覆盖成员变量当可以通过this来区分相类似
    - 重写的要求：
        - 两同： 方法名相同、参数列表相同
        - 两小： 子类返回值类型比父类的更小或相等； 子类方法抛出异常类应该比父类抛出的更小或相等
        - 一大： 子类方法的访问权限应该比父类的更大或相等
        - 覆盖方法与被覆盖方法需要都为静态方法或者都为实例方法
    - 如果父类的方法使用private修饰的，那么子类无法重写
    - this, super不能出现在static修饰的方法中
- super
    - 让子类可以调用父类的构造器，用法与this类型， 比如 super(name1, name2) 
    - 用于限定该对象调用它从父类继承得到的**实例变量和方法**
    - 在构造器中使用super则限定该构造器初始化的是从父类继承得到的实例变量，而不是该子类自己定义的实例变量
    - 子类定义了和父类相同的变量，可以通过super区分
> 当覆盖类变量或者类方法是，可以直接通过类名访问
> 当创建一个子类对象时，系统会为该对象分配两个内存，一个用来存储子类定义的变量，另一个用来存储从父类继承来的变量
