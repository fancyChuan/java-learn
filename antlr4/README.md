

解析器：能够分析、计算、执行语句的程序。比如计算器、读取配置文件的程序、python解释器

翻译器：将一门语言转换为另一门语言的程序。比如java到C#的转换器和普通的编译器

语法分析器parser（或者叫句法分析器syntax analyzer）：识别语言的程序
- 句法syntax：约束语言中的各个组成部分之间关系的规则
- 语法grammar：一系列规则的集合，每条规则表述出一种词汇结构

ANTLR元语言：antlr语法本身遵循的一种专门用来描述其他语言的语法


词法分析器lexer：把输入的文本转为词法符号的程序
- 词法分析lexical analysis（或者叫词法符号化tokenizing）： 将字符聚集为单词或者符号token的过程
- 词法符号至少包含两部分信息：
    - 词法符号的类型（从而能够通过类型来识别词法结构）
    - 该词法符号对应的文本
    

递归下降的语法分析器最神奇的地方在于：通过对方法stat() assign() expr() 的调用描述出调用路线图，并将其映射到语法分析书的节点上
```
// assign: ID '=' expr ';'
void assign() {     // 根据assign规则生成的方法
    match(ID);      // 将当前的输入符号和ID相比较，然后将其消费掉
    match('=');
    expr();         // 通过调用方法expr() 来匹配一个表达式
    match(';');
}
```
- 调用match()对应了语法分析树的叶子节点。也就是说：在match()的实现方法中，要有“增加一个新的叶子节点”这样的操作


```
// 从当前输入位置开始，匹配多种语句
stat: assign        // 第一个备选分支 （'|'符号是备选分支的分隔符）
    | ifstat
    | whilestat
    ...
    
// 对上面这个规则的解析更像是一个switch语句：
void stat() {
    switch( << 当前输入的词法符号 >> )
        case ID     : assign(); break;
        case IF     : ifstat(); break; // IF 是if关键词的词法符号类型
        case WHILE  : whilestat(); break;
        ...
        default     : << 抛出无可选方案的异常 >>
}

```
- 因此在上面的这个规则中，stat()方法必须通过检查下一个词法符号做出语法分析决策或者预测，决定选择哪个备选分支


前瞻词法符号lookahead token： 指任何一个在被匹配和消费之前就由语法分析器嗅探出的词法符号

> 语法分析器在分析语法的时候，需要做各种各样的决策。比如上述例子中，走到stat()就需要决定接下来往哪个分支走，而ID、IF、WHILE就可以理解为前瞻词法符号，它能告诉词法分析器应该往哪里走。当然，有的时候需要更多的前瞻词法符号才能做出决策，也就是遇到歧义性语句时

歧义性语句: 指存在不止一种语义的语句。也就是说，这种语句中的单词序列能够匹配多种语法结构

