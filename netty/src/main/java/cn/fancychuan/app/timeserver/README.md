## 时间服务的4种实现

#### 1. 使用BIO实现时间服务
- 传统的做法：一个客户端请求新建一个线程，同步且阻塞
- 优化的做法：使用线程池，n个线程服务M个客户端，伪异步
> 阻塞有两个地方：服务端server.accept()，等待输入流的readline()。客户端也存在阻塞的情况。
比如客户端需要60秒才能发送完数据，客户端需要等待60秒拿到数据，之后处理10秒，客户端再等10秒才能拿到处理结果反馈

伪异步IO的弊端分析：
- 输入流InputStream：read()这个方法在对socket的输入流进行读取操作的时候，会阻塞，直到下面三种情况：
    - 有数据可读
    - 可用数据已读取完毕
    - 发生空指针或者IO异常
> 也就是说使用 socket.getInputStream().read()的时候，会堵塞，遇到网络问题等情况的时候会导致资源的空闲等待

- 输出流OutputStream: write()方法也会被阻塞，直到遇到两种情况：
    - 所有要发送的字节写入完成
    - 发生异常
> 当消息的接收方处理缓慢不能及时从TCP/IP的缓冲区读取数据的时候，会导致消息的发送方无法继续发送数据到缓冲区，这时双方都处于keep-alive状态

也就是说：读和写的操作都是同步阻塞的，阻塞的时间取决于对方IO线程的处理速度和网络IO的传输速度
> 通过引用依赖对方的处理速度，可靠性将变得非常差。允许实验环境表现良好，但一旦上线，面对恶劣的网络环境和良莠不齐的第三方系统，问题就会激增

可能存在的级联故障：
- 某个系统处理缓慢，导致依赖该系统应答的线程阻塞等待（因为使用read操作）
- 线程池的所有可用线程都阻塞，导致后续的所有IO消息在队列中排队
- 线程池采用阻塞队列实现，队列积满之后，后续的入队列的操作被阻塞
- 前端只有一个Acceptor线程接收客户端接入，被阻塞后新的客户端连接请求会被拒绝，客户端发生大量连接超时
- 由于几乎所有的链接都超时，调用者会认为系统已经崩溃了，无法接收新的请求消息

#### 2. 使用NIO实现时间服务

使用AIO实现时间服务

使用netty实现时间服务