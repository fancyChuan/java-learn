

## 2. 高并发IO的底层原理
### 2.1 IO读写的原理
简单来说，应用程序的IO操作实际上不是物理设备级别的读写，而是缓存的复制。
具体来说，上层应用通过操作系统的read系统调用把数据从内核缓冲区复制到应用程序的进程缓冲区，
通过操作系统的write系统调用把数据从应用程序的进程缓冲区复制到操作系统的内核缓冲区。


为了减少底层系统的频繁中断所导致的时间损耗、性能损耗，出现了内核缓冲区

在Linux系统中，操作系统内核只有一个内核缓冲区。每个用户程序（进程）都有自己独立的缓冲区，叫作用户缓冲区或者进程缓冲区。

### 2.2　四种主要的IO模型
“阻塞”指的是用户程序（发起IO请求的进程或者线程）的执行状态。可以说传统的IO模型都是阻塞IO模型，并且在Java中默认创建的socket都属于阻塞IO模型。

阻塞IO指的是需要内核IO操作彻底完成后才返回到用户空间执行用户程序的操作指令

#### 2.2.1 同步阻塞IO
同步阻塞IO（Blocking IO）指的是用户空间（或者线程）主动发起，需要等待内核IO操作彻底完成后才返回到用户空间的IO操作。
在IO操作过程中，发起IO请求的用户进程（或者线程）处于阻塞状态

![image](images/Java高并发编程卷1/图2-2同步阻塞IO的流程.png)

#### 2.2.2 同步非阻塞IO
非阻塞IO（Non-Blocking IO，NIO）指的是用户空间的程序不需要等待内核IO操作彻底完成，可以立即返回用户空间去执行后续的指令，
即发起IO请求的用户进程（或者线程）处于非阻塞状态，与此同时，内核会立即返回给用户一个IO状态值。

非阻塞是指用户进程（或者线程）获得内核返回的状态值就返回自己的空间，可以去做别的事情。在Java中，非阻塞IO的socket被设置为NONBLOCK模式。

![image](images/Java高并发编程卷1/图2-3同步非阻塞IO的流程.png)

- 特点：应用系统的线程回不断的进行IO系统调用。不断的轮询数据是否准备好，直到IO系统调用完成为止。
- 优点：用户线程不用阻塞，实时性较好。
- 缺点：需要不断的轮询内核，将占用大量CPU时间，效率低下
> 在Java的实际开发中，不会涉及这种IO模型，但是此模型还是有价值的，其作用在于其他IO模型中可以使用非阻塞IO模型作为基础，以实现其高性能。

#### 2.2.3 IO多路复用
如何避免同步非阻塞IO模型中轮询等待的问题呢？答案是采用IO多路复用模型。
IO多路复用（IO Multiplexing）属于一种经典的Reactor模式实现，有时也称为异步阻塞IO，Java中的Selector属于这种模型。

![image](images/Java高并发编程卷1/图2-4IO多路复用模型的read系统调用流程.png)

目前支持IO多路复用的系统调用有select、epoll等

#### 2.2.4 异步IO
异步IO（Asynchronous IO，AIO）指的是用户空间的线程变成被动接收者，而内核空间成为主动调用者

异步IO类似于Java中典型的回调模式，用户进程（或者线程）向内核空间注册了各种IO事件的回调函数，由内核去主动调用。


